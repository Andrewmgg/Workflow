# Набор полиморфных цифровых фильтров

Создать набор фильтров которые могут быть связаны в цепочку, и которые могут последовательно преобразовать цифровой
сигнал в другой. Фильтры должны обладать различными алгоритмами обработки сигналов например умножитель, сумматор,
медианный, а также "фильтры" работающие с файлами.

## Решение

Прежде чем начать писать код, задачу необходимо спроектировать. Именно на этапе проектирования выясняться многие нюансы,
которые будут важны на этапе программирования.

### Проектирование

Сначала мы должны придумать пару конкретных достаточно непохожих фильтров, чтобы выявить, что у них может быть общего,
это важнейший этап для полиморфных иерархий.

Мы начнём со следующих фильтров:

* Фильтр умножающий сигнал на заданный коэффициент.

* Фильтр суммирующий сигнал на протяжении заданного числа отсчётов

* Фильтр берущий медиану на протяжении заданного числа отсчётов

* Фильтр берущий модуль сигнала

* Фильтр берущий заданное число отсчётов и накладывающий первую половину отсчётов на вторую половину отсчётов и
вычисляющий евклидову норму полученных сигналов (в дальнейшем мы будем называть такой фильтр повторительной петлёй)

* Фильтр пишущий сигнал в файл, который ничего не передаёт дальше.

Как видим у всех этих фильтров есть возможность принять и есть возможность передать сигнал. Также мы видим, что есть
фильтры требующие для своей работы накопления числа отсчётов (суматор, медиана, петля), то есть они начинают передавать
сигнал не раньше, чем возьмут определённое число отсчётов, значит у нас должен быть метод, сообщающий нам готов ли фильтр
передать сигнал. Каждый фильтр хранит указатель на последующий фильтр, у нас должны быть методы назначающий и берущий
данный указатель.

Итак у нас получилось 5 методов. Это и есть наш общий знаменатель полиморфизма. Мы видим, что методы назначающий и
берущий указатель на следующий фильтр работают всегда одинаково, следовательно они не являются виртуальными и реализованы
в самом базовом классе. Остальные методы как раз и реализуют все особенности полиморфного поведения, при чём их
сложно реализовать осмысленно в базовом классе следовательно данные методы являются чисто виртуальными.
